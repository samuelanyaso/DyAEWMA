// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>

using namespace Rcpp;

// thtC
double thtC(double y);
RcppExport SEXP _DyAEWMA_thtC(SEXP ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type y(ySEXP);
    rcpp_result_gen = Rcpp::wrap(thtC(y));
    return rcpp_result_gen;
END_RCPP
}
// findPvalue1sC
/*Computes the p-value from the empirical distribution of the charting statistic*/ double findPvalue1sC(NumericVector dist, double obsStat);
RcppExport SEXP _DyAEWMA_findPvalue1sC(SEXP distSEXP, SEXP obsStatSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type dist(distSEXP);
    Rcpp::traits::input_parameter< double >::type obsStat(obsStatSEXP);
    rcpp_result_gen = Rcpp::wrap(findPvalue1sC(dist, obsStat));
    return rcpp_result_gen;
END_RCPP
}
// empirW
/*Estimates the IC Empirical Distribution of the AEWMA chart  using the Bootstrap Method*/ NumericVector empirW(NumericVector x, int simutime, int n);
RcppExport SEXP _DyAEWMA_empirW(SEXP xSEXP, SEXP simutimeSEXP, SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< int >::type simutime(simutimeSEXP);
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(empirW(x, simutime, n));
    return rcpp_result_gen;
END_RCPP
}
// arlC
/*Estimates the ARL of the AEWMA control chart with p-values.*/ NumericVector arlC(double av, int ww, int simutime, double shift);
RcppExport SEXP _DyAEWMA_arlC(SEXP avSEXP, SEXP wwSEXP, SEXP simutimeSEXP, SEXP shiftSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type av(avSEXP);
    Rcpp::traits::input_parameter< int >::type ww(wwSEXP);
    Rcpp::traits::input_parameter< int >::type simutime(simutimeSEXP);
    Rcpp::traits::input_parameter< double >::type shift(shiftSEXP);
    rcpp_result_gen = Rcpp::wrap(arlC(av, ww, simutime, shift));
    return rcpp_result_gen;
END_RCPP
}
// arl_atsC
/*Computes the ARL & ATS for the AEWMA chart with a dynamic sampling scheme.*/ NumericVector arl_atsC(double alpha, int ww, int simutime, double a, double lambda, double b, double shift);
RcppExport SEXP _DyAEWMA_arl_atsC(SEXP alphaSEXP, SEXP wwSEXP, SEXP simutimeSEXP, SEXP aSEXP, SEXP lambdaSEXP, SEXP bSEXP, SEXP shiftSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< int >::type ww(wwSEXP);
    Rcpp::traits::input_parameter< int >::type simutime(simutimeSEXP);
    Rcpp::traits::input_parameter< double >::type a(aSEXP);
    Rcpp::traits::input_parameter< double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< double >::type b(bSEXP);
    Rcpp::traits::input_parameter< double >::type shift(shiftSEXP);
    rcpp_result_gen = Rcpp::wrap(arl_atsC(alpha, ww, simutime, a, lambda, b, shift));
    return rcpp_result_gen;
END_RCPP
}
// arla
/*Component for estimating the ARL of the two-sided Adaptive EWMA chart*/ NumericVector arla(double h, double omg, double shift);
RcppExport SEXP _DyAEWMA_arla(SEXP hSEXP, SEXP omgSEXP, SEXP shiftSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type h(hSEXP);
    Rcpp::traits::input_parameter< double >::type omg(omgSEXP);
    Rcpp::traits::input_parameter< double >::type shift(shiftSEXP);
    rcpp_result_gen = Rcpp::wrap(arla(h, omg, shift));
    return rcpp_result_gen;
END_RCPP
}
// arlb
/*Component for estimating the ARL of the one sided Adaptive EWMA chart*/ NumericVector arlb(double h, double omg, double shift);
RcppExport SEXP _DyAEWMA_arlb(SEXP hSEXP, SEXP omgSEXP, SEXP shiftSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type h(hSEXP);
    Rcpp::traits::input_parameter< double >::type omg(omgSEXP);
    Rcpp::traits::input_parameter< double >::type shift(shiftSEXP);
    rcpp_result_gen = Rcpp::wrap(arlb(h, omg, shift));
    return rcpp_result_gen;
END_RCPP
}
// EmprDist
/*Estimates the empirical distribution of the classical EWMA control chart using a Bootstrap technique. Here, we use the method suggested by Haq to estimate the shift size, and the one sided chart has a max operation.  Definition of parameters simutime - Number of replications w - size required to reach steady state. z - vector of available IC data set */ NumericVector EmprDist(int simutime, int w, NumericVector z);
RcppExport SEXP _DyAEWMA_EmprDist(SEXP simutimeSEXP, SEXP wSEXP, SEXP zSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type simutime(simutimeSEXP);
    Rcpp::traits::input_parameter< int >::type w(wSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type z(zSEXP);
    rcpp_result_gen = Rcpp::wrap(EmprDist(simutime, w, z));
    return rcpp_result_gen;
END_RCPP
}
// arl_maxC
/*Computes the ARL for the one-sided maxx AEWMA chart without a dynamic sampling scheme.*/ NumericVector arl_maxC(double alpha, int ww, int simutime, double shift);
RcppExport SEXP _DyAEWMA_arl_maxC(SEXP alphaSEXP, SEXP wwSEXP, SEXP simutimeSEXP, SEXP shiftSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< int >::type ww(wwSEXP);
    Rcpp::traits::input_parameter< int >::type simutime(simutimeSEXP);
    Rcpp::traits::input_parameter< double >::type shift(shiftSEXP);
    rcpp_result_gen = Rcpp::wrap(arl_maxC(alpha, ww, simutime, shift));
    return rcpp_result_gen;
END_RCPP
}
// arl_ats_max
/*Computes the ARL & ATS for the one-sided maxx AEWMA chart with a dynamic sampling scheme.*/ NumericVector arl_ats_max(double alpha, int ww, int simutime, double a, double lambda, double b, double shift);
RcppExport SEXP _DyAEWMA_arl_ats_max(SEXP alphaSEXP, SEXP wwSEXP, SEXP simutimeSEXP, SEXP aSEXP, SEXP lambdaSEXP, SEXP bSEXP, SEXP shiftSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< int >::type ww(wwSEXP);
    Rcpp::traits::input_parameter< int >::type simutime(simutimeSEXP);
    Rcpp::traits::input_parameter< double >::type a(aSEXP);
    Rcpp::traits::input_parameter< double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< double >::type b(bSEXP);
    Rcpp::traits::input_parameter< double >::type shift(shiftSEXP);
    rcpp_result_gen = Rcpp::wrap(arl_ats_max(alpha, ww, simutime, a, lambda, b, shift));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_DyAEWMA_thtC", (DL_FUNC) &_DyAEWMA_thtC, 1},
    {"_DyAEWMA_findPvalue1sC", (DL_FUNC) &_DyAEWMA_findPvalue1sC, 2},
    {"_DyAEWMA_empirW", (DL_FUNC) &_DyAEWMA_empirW, 3},
    {"_DyAEWMA_arlC", (DL_FUNC) &_DyAEWMA_arlC, 4},
    {"_DyAEWMA_arl_atsC", (DL_FUNC) &_DyAEWMA_arl_atsC, 7},
    {"_DyAEWMA_arla", (DL_FUNC) &_DyAEWMA_arla, 3},
    {"_DyAEWMA_arlb", (DL_FUNC) &_DyAEWMA_arlb, 3},
    {"_DyAEWMA_EmprDist", (DL_FUNC) &_DyAEWMA_EmprDist, 3},
    {"_DyAEWMA_arl_maxC", (DL_FUNC) &_DyAEWMA_arl_maxC, 4},
    {"_DyAEWMA_arl_ats_max", (DL_FUNC) &_DyAEWMA_arl_ats_max, 7},
    {NULL, NULL, 0}
};

RcppExport void R_init_DyAEWMA(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
